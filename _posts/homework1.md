---
layout: post
title: homework1
date: 2018-3-12
categories: 作业
tags: 博客
---

# homework1

标签（空格分隔）： 系统分析与设计 软件工程

---

##1.简单题目

### a. 软件工程定义
    软件工程是将系统化、规范化、可度量化的方法应用于软件的开发、运行和维护的过程，也就是将工程化的方法应用于软件中以及对这些方法的研究。

###  b. software crisis和COCOMO模型
    软件危机一词是用于描述在计算机科学的早些发展时候，人们在无法按要求在规定时间内编写有效和有用的程序所遇到的困难。
    COCOMO(constructive cost model)模型是一种过程式的软件成本估计模型。COCOMO使用三种层次的模型来反映不同程度的复杂性。

### c. 软件生命周期
    软件生命周期（software life cycle)是软件的产生直到报废或停止使用的生命周期，还有一种旧的概念指的是软件开发过程中有问题定义、可行性分析、总体描述、系统设计、编码、调试和测试、验收与运行、维护升级到废弃等阶段的整个周期。软件生命周期也包括多种模型如大爆炸模型，瀑布模型以及螺旋模型等。

### d. 本课程关注的KA
我认为本科程关注的知识领域（ka）有：
软件需求、软件维护、软件配置管理、软件工程管理四个方面。

### e. CMMI的五个级别的解释
 CMMI全称是Capability Maturity Model Integration，即能力成熟度模型集成，是美国国防部的一个构想。CMMI定义了如下5个成熟度级别：初始，管理，定义，定量管理和优化。
> * 成熟等级1-初始
表示软件开发的初始过程，此时过程是无序的甚至是混乱的。

> * 成熟等级2-管理
建立了基本的项目管理过程来跟踪费用、进度和功能特性。制定了必要的过程纪律，能重复早先类似应用项目取得的成功经验。

> * 成熟等级3-定义
已将软件管理和工程两方面的过程文档化、标准化，并综合成该组织的标准软件过程。所有项目均使用经批准、剪裁的标准软件过程来开发和维护软件，软件产品的生产在整个软件过程是可见的。

> * 成熟等级4-定量管理
析对软件过程和产品质量的详细度量数据，对软件过程和产品都有定量的理解与控制。管理有一个作出结论的客观依据，管理能够在定量的范围内预测性能。

> * 成熟等级5-优化
过程的量化反馈和先进的新思想、新技术促使过程持续不断改进。
每个等级都被分解为过程域，特殊目标和特殊实践，通用目标、通用实践和共同特性.每个等级都有几个过程区域组成，这几个过程域共同形成一种软件过程能力。每个过程域，都有一些特殊目标和通用目标，通过相应的特殊实践和通用实践来实现这些目标。当一个过程域的所有特殊实践和通用实践都按要求得到实施，就能实现该过程域的目标。

> * 关于SWEBok的解释：
SWEBOK是涉及软件工程各个方面知识的体系结构。IEEE认为软件程向职业化状态演化的关键是在一个核心体系知识上达成一致，所以创建了SWEBOK的知识体系。SWEBOK指南有以下5个目的：（1）促进世界范围内对软件工程的一致性观点（2）阐明软件工程相对其它学科的额位置，并确立它们的分界（3）刻画软件工程学科的内容（4）提供使用知识体系的主题（5）为开发课程表和个人认证与许可材料，提供一个基础。
总的来说SWEBOKv3包括15个知识领域：软件需求、软件设计、软件构筑、软件测试、软件维护、软件配置管理、软件工程管理、软件工程过程、软件工程工具与方法、软件质量、软件工程专业实践、软件工程经济学、计算基础、数学基础、工程基金会。



##2.解释PSP各项指标以及技能要求
PSP 2.1的相关图表如下：

|mission|任务|
|-------|--------|
| planning | 计划 |
| · Estimate |  · 估计这个任务需要多少时间|
| Development | 开发 |
|·Analysis|·需求分析|
|·Design Spec|·生成设计文档|
|·Design Review|·设计复审|
|·coding Standard|·代码规范|
|·design|·具体设计|
|·coding|·具体编码|
|·test|·测试|
|Rporting|报告|
|·test report|·测试报告|
|·size measurement|·计算工作量|
|postmortem & process Improvement|·事后总结和改进想法|

而作为一个软件工程师则必须相应的掌握上述的一些技能。比如说计划、需求分析、代码规范、具体编码、测试以及总结等。对于这些目标可以通过设计计划书，作市场调查功能分析，阅读网络上相应的代码规范，学习相关的技术，进行各种各样的功能测试和事后讨论和总结来完成。
